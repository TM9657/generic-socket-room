declare function H0(D: any, $: any, F: any): Promise<any>;
declare function O0(D: any, $: any): Promise<q>;
declare class q {
    constructor(D: any, $?: {});
    stateChangeCallbacks: {
        open: any[];
        close: any[];
        error: any[];
        message: any[];
    };
    channels: any[];
    sendBuffer: any[];
    ref: number;
    timeout: any;
    transport: any;
    establishedConnections: number;
    defaultEncoder: any;
    defaultDecoder: any;
    closeWasClean: boolean;
    binaryType: any;
    connectClock: number;
    encode: any;
    decode: any;
    conn: any;
    heartbeatIntervalMs: any;
    rejoinAfterMs: (G: any) => any;
    reconnectAfterMs: (G: any) => any;
    logger: any;
    longpollerTimeout: any;
    params: any;
    endPoint: string;
    vsn: any;
    heartbeatTimeoutTimer: any;
    heartbeatTimer: any;
    pendingHeartbeatRef: any;
    reconnectTimer: g;
    location: any;
    getLongPollTransport(): typeof z;
    replaceTransport(D: any): void;
    protocol(): "wss" | "ws";
    endPointURL(): any;
    disconnect(D: any, $: any, F: any): void;
    connect(D: any): void;
    log(D: any, $: any, F: any): void;
    hasLogger(): boolean;
    onOpen(D: any): string;
    onClose(D: any): string;
    onError(D: any): string;
    onMessage(D: any): string;
    ping(D: any): boolean;
    clearHeartbeats(): void;
    onConnOpen(): void;
    heartbeatTimeout(): void;
    resetHeartbeat(): void;
    teardown(D: any, $: any, F: any): any;
    waitForBufferDone(D: any, $?: number): void;
    waitForSocketClosed(D: any, $?: number): void;
    onConnClose(D: any): void;
    onConnError(D: any): void;
    triggerChanError(): void;
    connectionState(): "closed" | "connecting" | "open" | "closing";
    isConnected(): boolean;
    remove(D: any): void;
    off(D: any): void;
    channel(D: any, $?: {}): _;
    push(D: any): void;
    makeRef(): string;
    sendHeartbeat(): void;
    flushSendBuffer(): void;
    onConnMessage(D: any): void;
    leaveOpenTopic(D: any): void;
}
declare class g {
    constructor(D: any, $: any);
    callback: any;
    timerCalc: any;
    timer: any;
    tries: number;
    reset(): void;
    scheduleTimeout(): void;
}
declare class z {
    constructor(D: any);
    endPoint: any;
    token: any;
    skipHeartbeat: boolean;
    reqs: Set<any>;
    awaitingBatchAck: boolean;
    currentBatch: any;
    currentBatchTimer: any;
    batchBuffer: any[];
    onopen: () => void;
    onerror: () => void;
    onmessage: () => void;
    onclose: () => void;
    pollEndpoint: any;
    readyState: number;
    normalizeEndpoint(D: any): any;
    endpointURL(): any;
    closeAndRetry(D: any, $: any, F: any): void;
    ontimeout(): void;
    isActive(): boolean;
    poll(): void;
    send(D: any): void;
    batchSend(D: any): void;
    close(D: any, $: any, F: any): void;
    ajax(D: any, $: any, F: any, G: any, Q: any): void;
    timeout(D: any, $: any, F: any, G: any, Q: any, Y: any, I: any): void;
}
declare class _ {
    constructor(D: any, $: any, F: any);
    state: string;
    topic: any;
    params: any;
    socket: any;
    bindings: any[];
    bindingRef: number;
    timeout: any;
    joinedOnce: boolean;
    joinPush: any;
    pushBuffer: any[];
    stateChangeRefs: any;
    rejoinTimer: g;
    join(D?: any): any;
    onClose(D: any): void;
    onError(D: any): number;
    on(D: any, $: any): number;
    off(D: any, $: any): void;
    canPush(): boolean;
    push(D: any, $: any, F?: any): H;
    leave(D?: any): H;
    onMessage(D: any, $: any, F: any, G: any): any;
    isMember(D: any, $: any, F: any, G: any): boolean;
    joinRef(): any;
    rejoin(D?: any): void;
    trigger(D: any, $: any, F: any, G: any): void;
    replyEventName(D: any): string;
    isClosed(): boolean;
    isErrored(): boolean;
    isJoined(): boolean;
    isJoining(): boolean;
    isLeaving(): boolean;
}
declare class H {
    constructor(D: any, $: any, F: any, G: any);
    channel: any;
    event: any;
    payload: any;
    receivedResp: any;
    timeout: any;
    timeoutTimer: any;
    recHooks: any[];
    sent: boolean;
    ref: any;
    refEvent: any;
    resend(D: any): void;
    send(): void;
    receive(D: any, $: any): H;
    reset(): void;
    matchReceive({ status: D, response: $, _ref: F }: {
        status: any;
        response: any;
        _ref: any;
    }): void;
    cancelRefEvent(): void;
    cancelTimeout(): void;
    startTimeout(): void;
    hasReceived(D: any): boolean;
    trigger(D: any, $: any): void;
}
export { H0 as join, O0 as connect };
