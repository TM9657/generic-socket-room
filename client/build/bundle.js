var K=(D)=>{if(typeof D==="function")return D;else return function(){return D}};var T=typeof self!=="undefined"?self:null,R=typeof window!=="undefined"?window:null,O=T||R||O,h="2.0.0",B={connecting:0,open:1,closing:2,closed:3},C=1e4,A=1000,U={closed:"closed",errored:"errored",joined:"joined",joining:"joining",leaving:"leaving"},M={close:"phx_close",error:"phx_error",join:"phx_join",reply:"phx_reply",leave:"phx_leave"},j={longpoll:"longpoll",websocket:"websocket"},N={complete:4};class H{channel;event;payload;receivedResp;timeout;timeoutTimer;recHooks;sent;ref;refEvent;constructor(D,$,F,G){this.channel=D,this.event=$,this.payload=F||function(){return{}},this.receivedResp=null,this.timeout=G,this.timeoutTimer=null,this.recHooks=[],this.sent=!1}resend(D){this.timeout=D,this.reset(),this.send()}send(){if(this.hasReceived("timeout"))return;this.startTimeout(),this.sent=!0,this.channel.socket.push({topic:this.channel.topic,event:this.event,payload:this.payload(),ref:this.ref,join_ref:this.channel.joinRef()})}receive(D,$){if(this.hasReceived(D)){if($)$(this.receivedResp.response)}return this.recHooks.push({status:D,callback:$}),this}reset(){this.cancelRefEvent(),this.ref=null,this.refEvent=null,this.receivedResp=null,this.sent=!1}matchReceive({status:D,response:$,_ref:F}){this.recHooks.filter((G)=>G.status===D).forEach((G)=>G.callback($))}cancelRefEvent(){if(!this.refEvent)return;this.channel.off(this.refEvent)}cancelTimeout(){clearTimeout(this.timeoutTimer),this.timeoutTimer=null}startTimeout(){if(this.timeoutTimer)this.cancelTimeout();this.ref=this.channel.socket.makeRef(),this.refEvent=this.channel.replyEventName(this.ref),this.channel.on(this.refEvent,(D)=>{this.cancelRefEvent(),this.cancelTimeout(),this.receivedResp=D,this.matchReceive(D)}),this.timeoutTimer=setTimeout(()=>{this.trigger("timeout",{})},this.timeout)}hasReceived(D){return this.receivedResp&&this.receivedResp.status===D}trigger(D,$){this.channel.trigger(this.refEvent,{status:D,response:$})}}class g{callback;timerCalc;timer;tries;constructor(D,$){this.callback=D,this.timerCalc=$,this.timer=null,this.tries=0}reset(){this.tries=0,clearTimeout(this.timer)}scheduleTimeout(){clearTimeout(this.timer),this.timer=setTimeout(()=>{this.tries=this.tries+1,this.callback()},this.timerCalc(this.tries+1))}}class _{state;topic;params;socket;bindings;bindingRef;timeout;joinedOnce;joinPush;pushBuffer;stateChangeRefs;rejoinTimer;constructor(D,$,F){this.state=U.closed,this.topic=D,this.params=K($||{}),this.socket=F,this.bindings=[],this.bindingRef=0,this.timeout=this.socket.timeout,this.joinedOnce=!1,this.joinPush=new H(this,M.join,this.params,this.timeout),this.pushBuffer=[],this.stateChangeRefs=[],this.rejoinTimer=new g(()=>{if(this.socket.isConnected())this.rejoin()},this.socket.rejoinAfterMs),this.stateChangeRefs.push(this.socket.onError(()=>this.rejoinTimer.reset())),this.stateChangeRefs.push(this.socket.onOpen(()=>{if(this.rejoinTimer.reset(),this.isErrored())this.rejoin()})),this.joinPush.receive("ok",()=>{this.state=U.joined,this.rejoinTimer.reset(),this.pushBuffer.forEach((G)=>G.send()),this.pushBuffer=[]}),this.joinPush.receive("error",()=>{if(this.state=U.errored,this.socket.isConnected())this.rejoinTimer.scheduleTimeout()}),this.onClose(()=>{if(this.rejoinTimer.reset(),this.socket.hasLogger())this.socket.log("channel",`close ${this.topic} ${this.joinRef()}`);this.state=U.closed,this.socket.remove(this)}),this.onError((G)=>{if(this.socket.hasLogger())this.socket.log("channel",`error ${this.topic}`,G);if(this.isJoining())this.joinPush.reset();if(this.state=U.errored,this.socket.isConnected())this.rejoinTimer.scheduleTimeout()}),this.joinPush.receive("timeout",()=>{if(this.socket.hasLogger())this.socket.log("channel",`timeout ${this.topic} (${this.joinRef()})`,this.joinPush.timeout);if(new H(this,M.leave,K({}),this.timeout).send(),this.state=U.errored,this.joinPush.reset(),this.socket.isConnected())this.rejoinTimer.scheduleTimeout()}),this.on(M.reply,(G,Q)=>{this.trigger(this.replyEventName(Q),G)})}join(D=this.timeout){if(this.joinedOnce)throw new Error("tried to join multiple times. 'join' can only be called a single time per channel instance");else return this.timeout=D,this.joinedOnce=!0,this.rejoin(),this.joinPush}onClose(D){this.on(M.close,D)}onError(D){return this.on(M.error,($)=>D($))}on(D,$){let F=this.bindingRef++;return this.bindings.push({event:D,ref:F,callback:$}),F}off(D,$){this.bindings=this.bindings.filter((F)=>{return!(F.event===D&&(typeof $==="undefined"||$===F.ref))})}canPush(){return this.socket.isConnected()&&this.isJoined()}push(D,$,F=this.timeout){if($=$||{},!this.joinedOnce)throw new Error(`tried to push '${D}' to '${this.topic}' before joining. Use channel.join() before pushing events`);let G=new H(this,D,function(){return $},F);if(this.canPush())G.send();else G.startTimeout(),this.pushBuffer.push(G);return G}leave(D=this.timeout){this.rejoinTimer.reset(),this.joinPush.cancelTimeout(),this.state=U.leaving;let $=()=>{if(this.socket.hasLogger())this.socket.log("channel",`leave ${this.topic}`);this.trigger(M.close,"leave")},F=new H(this,M.leave,K({}),D);if(F.receive("ok",()=>$()).receive("timeout",()=>$()),F.send(),!this.canPush())F.trigger("ok",{});return F}onMessage(D,$,F,G){return $}isMember(D,$,F,G){if(this.topic!==D)return!1;if(G&&G!==this.joinRef()){if(this.socket.hasLogger())this.socket.log("channel","dropping outdated message",{topic:D,event:$,payload:F,joinRef:G});return!1}else return!0}joinRef(){return this.joinPush.ref}rejoin(D=this.timeout){if(this.isLeaving())return;this.socket.leaveOpenTopic(this.topic),this.state=U.joining,this.joinPush.resend(D)}trigger(D,$,F,G){let Q=this.onMessage(D,$,F,G);if($&&!Q)throw new Error("channel onMessage callbacks must return the payload, modified or unmodified");let Y=this.bindings.filter((I)=>I.event===D);for(let I=0;I<Y.length;I++)Y[I].callback(Q,F,G||this.joinRef())}replyEventName(D){return`chan_reply_${D}`}isClosed(){return this.state===U.closed}isErrored(){return this.state===U.errored}isJoined(){return this.state===U.joined}isJoining(){return this.state===U.joining}isLeaving(){return this.state===U.leaving}}class J{static request(D,$,F,G,Q,Y,I){if(O.XDomainRequest){let Z=new O.XDomainRequest;return this.xdomainRequest(Z,D,$,G,Q,Y,I)}else{let Z=new O.XMLHttpRequest;return this.xhrRequest(Z,D,$,F,G,Q,Y,I)}}static xdomainRequest(D,$,F,G,Q,Y,I){if(D.timeout=Q,D.open($,F),D.onload=()=>{let Z=this.parseJSON(D.responseText);I&&I(Z)},Y)D.ontimeout=Y;return D.onprogress=()=>{},D.send(G),D}static xhrRequest(D,$,F,G,Q,Y,I,Z){if(D.open($,F,!0),D.timeout=Y,D.setRequestHeader("Content-Type",G),D.onerror=()=>Z&&Z(null),D.onreadystatechange=()=>{if(D.readyState===N.complete&&Z){let X=this.parseJSON(D.responseText);Z(X)}},I)D.ontimeout=I;return D.send(Q),D}static parseJSON(D){if(!D||D==="")return null;try{return JSON.parse(D)}catch($){return console&&console.log("failed to parse JSON response",D),null}}static serialize(D,$){let F=[];for(var G in D){if(!Object.prototype.hasOwnProperty.call(D,G))continue;let Q=$?`${$}[${G}]`:G,Y=D[G];if(typeof Y==="object")F.push(this.serialize(Y,Q));else F.push(encodeURIComponent(Q)+"="+encodeURIComponent(Y))}return F.join("&")}static appendParams(D,$){if(Object.keys($).length===0)return D;let F=D.match(/\?/)?"&":"?";return`${D}${F}${this.serialize($)}`}}var E=(D)=>{let $="",F=new Uint8Array(D),G=F.byteLength;for(let Q=0;Q<G;Q++)$+=String.fromCharCode(F[Q]);return btoa($)};class z{endPoint;token;skipHeartbeat;reqs;awaitingBatchAck;currentBatch;currentBatchTimer;batchBuffer;onopen;onerror;onmessage;onclose;pollEndpoint;readyState;constructor(D){this.endPoint=null,this.token=null,this.skipHeartbeat=!0,this.reqs=new Set,this.awaitingBatchAck=!1,this.currentBatch=null,this.currentBatchTimer=null,this.batchBuffer=[],this.onopen=function(){},this.onerror=function(){},this.onmessage=function(){},this.onclose=function(){},this.pollEndpoint=this.normalizeEndpoint(D),this.readyState=B.connecting,this.poll()}normalizeEndpoint(D){return D.replace("ws://","http://").replace("wss://","https://").replace(new RegExp("(.*)/"+j.websocket),"$1/"+j.longpoll)}endpointURL(){return J.appendParams(this.pollEndpoint,{token:this.token})}closeAndRetry(D,$,F){this.close(D,$,F),this.readyState=B.connecting}ontimeout(){this.onerror("timeout"),this.closeAndRetry(1005,"timeout",!1)}isActive(){return this.readyState===B.open||this.readyState===B.connecting}poll(){this.ajax("GET","application/json",null,()=>this.ontimeout(),(D)=>{if(D){var{status:$,token:F,messages:G}=D;this.token=F}else $=0;switch($){case 200:G.forEach((Q)=>{setTimeout(()=>this.onmessage({data:Q}),0)}),this.poll();break;case 204:this.poll();break;case 410:this.readyState=B.open,this.onopen({}),this.poll();break;case 403:this.onerror(403),this.close(1008,"forbidden",!1);break;case 0:case 500:this.onerror(500),this.closeAndRetry(1011,"internal server error",500);break;default:throw new Error(`unhandled poll status ${$}`)}})}send(D){if(typeof D!=="string")D=E(D);if(this.currentBatch)this.currentBatch.push(D);else if(this.awaitingBatchAck)this.batchBuffer.push(D);else this.currentBatch=[D],this.currentBatchTimer=setTimeout(()=>{this.batchSend(this.currentBatch),this.currentBatch=null},0)}batchSend(D){this.awaitingBatchAck=!0,this.ajax("POST","application/x-ndjson",D.join("\n"),()=>this.onerror("timeout"),($)=>{if(this.awaitingBatchAck=!1,!$||$.status!==200)this.onerror($&&$.status),this.closeAndRetry(1011,"internal server error",!1);else if(this.batchBuffer.length>0)this.batchSend(this.batchBuffer),this.batchBuffer=[]})}close(D,$,F){for(let Q of this.reqs)Q.abort();this.readyState=B.closed;let G=Object.assign({code:1000,reason:void 0,wasClean:!0},{code:D,reason:$,wasClean:F});if(this.batchBuffer=[],clearTimeout(this.currentBatchTimer),this.currentBatchTimer=null,typeof CloseEvent!=="undefined")this.onclose(new CloseEvent("close",G));else this.onclose(G)}ajax(D,$,F,G,Q){let Y,I=()=>{this.reqs.delete(Y),G()};Y=J.request(D,this.endpointURL(),$,F,this.timeout,I,(Z)=>{if(this.reqs.delete(Y),this.isActive())Q(Z)}),this.reqs.add(Y)}timeout(D,$,F,G,Q,Y,I){throw new Error("Method not implemented.")}}var L={HEADER_LENGTH:1,META_LENGTH:4,KINDS:{push:0,reply:1,broadcast:2},encode(D,$){if(D.payload.constructor===ArrayBuffer)return $(this.binaryEncode(D));else{let F=[D.join_ref,D.ref,D.topic,D.event,D.payload];return $(JSON.stringify(F))}},decode(D,$){if(D.constructor===ArrayBuffer)return $(this.binaryDecode(D));else{let[F,G,Q,Y,I]=JSON.parse(D);return $({join_ref:F,ref:G,topic:Q,event:Y,payload:I})}},binaryEncode(D){let{join_ref:$,ref:F,event:G,topic:Q,payload:Y}=D,I=this.META_LENGTH+$.length+F.length+Q.length+G.length,Z=new ArrayBuffer(this.HEADER_LENGTH+I),X=new DataView(Z),W=0;X.setUint8(W++,this.KINDS.push),X.setUint8(W++,$.length),X.setUint8(W++,F.length),X.setUint8(W++,Q.length),X.setUint8(W++,G.length),Array.from($,(x)=>X.setUint8(W++,x.charCodeAt(0))),Array.from(F,(x)=>X.setUint8(W++,x.charCodeAt(0))),Array.from(Q,(x)=>X.setUint8(W++,x.charCodeAt(0))),Array.from(G,(x)=>X.setUint8(W++,x.charCodeAt(0)));var V=new Uint8Array(Z.byteLength+Y.byteLength);return V.set(new Uint8Array(Z),0),V.set(new Uint8Array(Y),Z.byteLength),V.buffer},binaryDecode(D){let $=new DataView(D),F=$.getUint8(0),G=new TextDecoder;switch(F){case this.KINDS.push:return this.decodePush(D,$,G);case this.KINDS.reply:return this.decodeReply(D,$,G);case this.KINDS.broadcast:return this.decodeBroadcast(D,$,G)}},decodePush(D,$,F){let G=$.getUint8(1),Q=$.getUint8(2),Y=$.getUint8(3),I=this.HEADER_LENGTH+this.META_LENGTH-1,Z=F.decode(D.slice(I,I+G));I=I+G;let X=F.decode(D.slice(I,I+Q));I=I+Q;let W=F.decode(D.slice(I,I+Y));I=I+Y;let V=D.slice(I,D.byteLength);return{join_ref:Z,ref:null,topic:X,event:W,payload:V}},decodeReply(D,$,F){let G=$.getUint8(1),Q=$.getUint8(2),Y=$.getUint8(3),I=$.getUint8(4),Z=this.HEADER_LENGTH+this.META_LENGTH,X=F.decode(D.slice(Z,Z+G));Z=Z+G;let W=F.decode(D.slice(Z,Z+Q));Z=Z+Q;let V=F.decode(D.slice(Z,Z+Y));Z=Z+Y;let x=F.decode(D.slice(Z,Z+I));Z=Z+I;let w=D.slice(Z,D.byteLength),P={status:x,response:w};return{join_ref:X,ref:W,topic:V,event:M.reply,payload:P}},decodeBroadcast(D,$,F){let G=$.getUint8(1),Q=$.getUint8(2),Y=this.HEADER_LENGTH+2,I=F.decode(D.slice(Y,Y+G));Y=Y+G;let Z=F.decode(D.slice(Y,Y+Q));Y=Y+Q;let X=D.slice(Y,D.byteLength);return{join_ref:null,ref:null,topic:I,event:Z,payload:X}}};class q{stateChangeCallbacks;channels;sendBuffer;ref;timeout;transport;establishedConnections;defaultEncoder;defaultDecoder;closeWasClean;binaryType;connectClock;encode;decode;conn;heartbeatIntervalMs;rejoinAfterMs;reconnectAfterMs;logger;longpollerTimeout;params;endPoint;vsn;heartbeatTimeoutTimer;heartbeatTimer;pendingHeartbeatRef;reconnectTimer;location;constructor(D,$={}){if(this.stateChangeCallbacks={open:[],close:[],error:[],message:[]},this.channels=[],this.sendBuffer=[],this.ref=0,this.timeout=$.timeout||C,this.transport=$.transport||O.WebSocket||z,this.establishedConnections=0,this.defaultEncoder=L.encode.bind(L),this.defaultDecoder=L.decode.bind(L),this.closeWasClean=!1,this.binaryType=$.binaryType||"arraybuffer",this.connectClock=1,this.transport!==z)this.encode=$.encode||this.defaultEncoder,this.decode=$.decode||this.defaultDecoder;else this.encode=this.defaultEncoder,this.decode=this.defaultDecoder;let F=null;if(R&&R.addEventListener)R.addEventListener("pagehide",(G)=>{if(this.conn)this.disconnect(),F=this.connectClock}),R.addEventListener("pageshow",(G)=>{if(F===this.connectClock)F=null,this.connect()});this.heartbeatIntervalMs=$.heartbeatIntervalMs||30000,this.rejoinAfterMs=(G)=>{if($.rejoinAfterMs)return $.rejoinAfterMs(G);else return[1000,2000,5000][G-1]||1e4},this.reconnectAfterMs=(G)=>{if($.reconnectAfterMs)return $.reconnectAfterMs(G);else return[10,50,100,150,200,250,500,1000,2000][G-1]||5000},this.logger=$.logger||null,this.longpollerTimeout=$.longpollerTimeout||20000,this.params=K($.params||{}),this.endPoint=`${D}/${j.websocket}`,this.vsn=$.vsn||h,this.heartbeatTimeoutTimer=null,this.heartbeatTimer=null,this.pendingHeartbeatRef=null,this.reconnectTimer=new g(()=>{this.teardown(()=>this.connect())},this.reconnectAfterMs)}getLongPollTransport(){return z}replaceTransport(D){if(this.connectClock++,this.closeWasClean=!0,this.reconnectTimer.reset(),this.sendBuffer=[],this.conn)this.conn.close(),this.conn=null;this.transport=D}protocol(){return location.protocol.match(/^https/)?"wss":"ws"}endPointURL(){let D=J.appendParams(J.appendParams(this.endPoint,this.params()),{vsn:this.vsn});if(D.charAt(0)!=="/")return D;if(D.charAt(1)==="/")return`${this.protocol()}:${D}`;return`${this.protocol()}://${location.host}${D}`}disconnect(D,$,F){this.connectClock++,this.closeWasClean=!0,this.reconnectTimer.reset(),this.teardown(D,$,F)}connect(D){if(D)console&&console.log("passing params to connect is deprecated. Instead pass :params to the Socket constructor"),this.params=K(D);if(this.conn)return;this.connectClock++,this.closeWasClean=!1,this.conn=new this.transport(this.endPointURL()),this.conn.binaryType=this.binaryType,this.conn.timeout=this.longpollerTimeout,this.conn.onopen=()=>this.onConnOpen(),this.conn.onerror=($)=>this.onConnError($),this.conn.onmessage=($)=>this.onConnMessage($),this.conn.onclose=($)=>this.onConnClose($)}log(D,$,F){this.logger(D,$,F)}hasLogger(){return this.logger!==null}onOpen(D){let $=this.makeRef();return this.stateChangeCallbacks.open.push([$,D]),$}onClose(D){let $=this.makeRef();return this.stateChangeCallbacks.close.push([$,D]),$}onError(D){let $=this.makeRef();return this.stateChangeCallbacks.error.push([$,D]),$}onMessage(D){let $=this.makeRef();return this.stateChangeCallbacks.message.push([$,D]),$}ping(D){if(!this.isConnected())return!1;let $=this.makeRef(),F=Date.now();this.push({topic:"phoenix",event:"heartbeat",payload:{},ref:$});let G=this.onMessage((Q)=>{if(Q.ref===$)this.off([G]),D(Date.now()-F)});return!0}clearHeartbeats(){clearTimeout(this.heartbeatTimer),clearTimeout(this.heartbeatTimeoutTimer)}onConnOpen(){if(this.hasLogger())this.log("transport",`connected to ${this.endPointURL()}`);this.closeWasClean=!1,this.establishedConnections++,this.flushSendBuffer(),this.reconnectTimer.reset(),this.resetHeartbeat(),this.stateChangeCallbacks.open.forEach(([,D])=>D())}heartbeatTimeout(){if(this.pendingHeartbeatRef){if(this.pendingHeartbeatRef=null,this.hasLogger())this.log("transport","heartbeat timeout. Attempting to re-establish connection");this.triggerChanError(),this.closeWasClean=!1,this.teardown(()=>this.reconnectTimer.scheduleTimeout(),A,"heartbeat timeout")}}resetHeartbeat(){if(this.conn&&this.conn.skipHeartbeat)return;this.pendingHeartbeatRef=null,this.clearHeartbeats(),this.heartbeatTimer=setTimeout(()=>this.sendHeartbeat(),this.heartbeatIntervalMs)}teardown(D,$,F){if(!this.conn)return D&&D();this.waitForBufferDone(()=>{if(this.conn)if($)this.conn.close($,F||"");else this.conn.close();this.waitForSocketClosed(()=>{if(this.conn)this.conn.onopen=function(){},this.conn.onerror=function(){},this.conn.onmessage=function(){},this.conn.onclose=function(){},this.conn=null;D&&D()})})}waitForBufferDone(D,$=1){if($===5||!this.conn||!this.conn.bufferedAmount){D();return}setTimeout(()=>{this.waitForBufferDone(D,$+1)},150*$)}waitForSocketClosed(D,$=1){if($===5||!this.conn||this.conn.readyState===B.closed){D();return}setTimeout(()=>{this.waitForSocketClosed(D,$+1)},150*$)}onConnClose(D){let $=D&&D.code;if(this.hasLogger())this.log("transport","close",D);if(this.triggerChanError(),this.clearHeartbeats(),!this.closeWasClean&&$!==1000)this.reconnectTimer.scheduleTimeout();this.stateChangeCallbacks.close.forEach(([,F])=>F(D))}onConnError(D){if(this.hasLogger())this.log("transport",D);let $=this.transport,F=this.establishedConnections;if(this.stateChangeCallbacks.error.forEach(([,G])=>{G(D,$,F)}),$===this.transport||F>0)this.triggerChanError()}triggerChanError(){this.channels.forEach((D)=>{if(!(D.isErrored()||D.isLeaving()||D.isClosed()))D.trigger(M.error)})}connectionState(){switch(this.conn&&this.conn.readyState){case B.connecting:return"connecting";case B.open:return"open";case B.closing:return"closing";default:return"closed"}}isConnected(){return this.connectionState()==="open"}remove(D){this.off(D.stateChangeRefs),this.channels=this.channels.filter(($)=>$.joinRef()!==D.joinRef())}off(D){for(let $ in this.stateChangeCallbacks)this.stateChangeCallbacks[$]=this.stateChangeCallbacks[$].filter(([F])=>{return D.indexOf(F)===-1})}channel(D,$={}){let F=new _(D,$,this);return this.channels.push(F),F}push(D){if(this.hasLogger()){let{topic:$,event:F,payload:G,ref:Q,join_ref:Y}=D;this.log("push",`${$} ${F} (${Y}, ${Q})`,G)}if(this.isConnected())this.encode(D,($)=>this.conn.send($));else this.sendBuffer.push(()=>this.encode(D,($)=>this.conn.send($)))}makeRef(){let D=this.ref+1;if(D===this.ref)this.ref=0;else this.ref=D;return this.ref.toString()}sendHeartbeat(){if(this.pendingHeartbeatRef&&!this.isConnected())return;this.pendingHeartbeatRef=this.makeRef(),this.push({topic:"phoenix",event:"heartbeat",payload:{},ref:this.pendingHeartbeatRef}),this.heartbeatTimeoutTimer=setTimeout(()=>this.heartbeatTimeout(),this.heartbeatIntervalMs)}flushSendBuffer(){if(this.isConnected()&&this.sendBuffer.length>0)this.sendBuffer.forEach((D)=>D()),this.sendBuffer=[]}onConnMessage(D){this.decode(D.data,($)=>{let{topic:F,event:G,payload:Q,ref:Y,join_ref:I}=$;if(Y&&Y===this.pendingHeartbeatRef)this.clearHeartbeats(),this.pendingHeartbeatRef=null,this.heartbeatTimer=setTimeout(()=>this.sendHeartbeat(),this.heartbeatIntervalMs);if(this.hasLogger())this.log("receive",`${Q.status||""} ${F} ${G} ${Y&&"("+Y+")"||""}`,Q);for(let Z=0;Z<this.channels.length;Z++){const X=this.channels[Z];if(!X.isMember(F,G,Q,I))continue;X.trigger(G,Q,Y,I)}for(let Z=0;Z<this.stateChangeCallbacks.message.length;Z++){let[,X]=this.stateChangeCallbacks.message[Z];X($)}})}leaveOpenTopic(D){let $=this.channels.find((F)=>F.topic===D&&(F.isJoined()||F.isJoining()));if($){if(this.hasLogger())this.log("transport",`leaving duplicate topic "${D}"`);$.leave()}}}async function O0(D,$){let F=new q(D,{params:{token:$}});return F.connect({params:{token:$}}),F}async function H0(D,$,F){let G=D.channel($,{params:{token:F}});return G.join(),G}export{H0 as join,O0 as connect};
